# shell脚本与vim编辑器

## 1、ctrl+s冻结
使用Xshell的时候在vim下按ctrl + s 之后就把终端锁定了。

解决方法是ctrl + q（如果登录微信，ctrl + q 被占用为截屏，那就按ctrl + z）。
查看相关组合键可以输入：stty -a

## 2、readonly用来定义只读变量，一旦使用readonly定义的变量在脚本中就不能更改
```
root@hankin:/usr/local/bin# echo $(printf "%d" "0xc")
12
root@hankin:/usr/local/bin# echo $(printf "%d" "0xcc")
204
```

## 3、终端单行函数需注意
文件：
```
#!/bin/bash

demoFun()
{
    echo "这是我的第一个 shell 函数!"
}

demoFun
```

终端：
demoFun() { echo "这是我的第一个 shell 函数!"; }; demoFun

注意多了一个分号。

## 4、nano编辑器
ctrl+o  保存，后面需要按一下回车键确认
ctrl+x  退出

## 5、vi编辑器
x   删除
无法在编辑模式进行上下左右

## 6、cat "${conf}" | grep -v ^\# | grep "^${key}=" | awk 'BEGIN{FS="="} {print $2}'详解
这是一个用于从配置文件中获取特定键值的命令。让我逐步解释每个部分的含义：

（1）cat "${conf}"：cat 命令用于将文件的内容输出到标准输出。${conf} 是一个变量，表示配置文件的路径。这个命令将配置文件的内容输出到下一个命令的标准输入。

（2）grep -v ^\#：grep 命令用于在输入中搜索匹配的文本行。-v 选项表示反向匹配，即只输出不匹配的行。^\# 是一个正则表达式，表示以 # 开头的行，即注释行。这个命令将过滤掉所有的注释行。

（3）grep "^${key}="：这是第二个 grep 命令，用于匹配以 ${key}= 开头的行。${key} 是一个变量，表示要搜索的键。这个命令将过滤掉不匹配键的行。

（4）awk 'BEGIN{FS="="} {print $2}'：awk 是一种文本处理工具，用于按照指定的规则处理文本行。BEGIN{FS="="} 是一个 awk 的特殊语法，用于设置字段分隔符为 =。{print $2} 表示打印每行的第二个字段，即键对应的值。

综上所述，该命令的作用是从配置文件中获取指定键的值，并将其输出到标准输出。

## 7、grep了多行只取其中一行
grep [匹配条件] [文件名] | head -n 1
在Bash中，-eq是用于数值比较的运算符，而${driver_type}是一个字符串。因此，应该使用=运算符进行字符串比较，而不是-eq运算符。

## 8、shell 去掉字符串首尾空格
echo "  hello world  " | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
echo "  hello world  " | awk '{$1=$1};1'

## 9、shell 去掉字符串首尾非数字字符
```
#!/bin/bash

str="abc123def456ghi"
echo "原始字符串：$str"

# 去掉首部非数字字符
str=${str##[^0-9]}
echo "去掉首部非数字字符后的字符串：$str"

# 去掉尾部非数字字符
str=${str%%[^0-9]}
echo "去掉首尾非数字字符后的字符串：$str"
```

## 10、在字符串中输出变量值
```
cmd="cat /sys/kernel/debug/usb/usbmon/${bus_number_nozero}u | grep '${bus_number_nozero}:${port_number}' >> ${USB_DATA_FILE_PATH}"
echo ${cmd}
```
在外围使用双引号，内围中使用单引号即可。

## 11、执行存储命令的变量
```
# eval命令可以解析并执行存储在变量中的命令。在这种情况下，$cmd将被替换为你保存的命令，并被执行
eval ${cmd}
```

## 12、shell脚本预防脚本多开
要预防Shell脚本的多开，你可以使用以下方法之一：
- 使用文件锁：在脚本的开头使用文件锁来确保只有一个实例在运行。你可以使用flock命令来实现文件锁。例如，在脚本开始时，可以创建一个锁文件，并在脚本结束时删除它。如果脚本再次运行时发现锁文件已存在，则表示已有一个实例在运行，脚本可以选择退出或等待。
- 使用进程检查：在脚本的开头，可以使用pgrep命令检查是否已有相同的脚本进程在运行。如果找到了相同的进程，脚本可以选择退出或等待。
- 使用环境变量：在脚本的开头，可以设置一个特定的环境变量，用于标记脚本是否已经在运行。当脚本再次运行时，可以检查该环境变量的值，如果已经被设置，则表示已有一个实例在运行，脚本可以选择退出或等待。

无论你选择哪种方法，都需要在脚本中添加适当的逻辑来处理多开情况。这样可以确保只有一个实例在运行，避免可能的冲突和错误。

## 13、神奇的赋值
```
#!/bin/bash

svn=2
[[ $svn =~ 1 ]] && svn_path="aaaa" && package_path="bbbb"
[[ $svn =~ 2 ]] && svn_path="cccc" && package_path="dddd"
echo $svn_path          # 已验证输出cccc
echo $package_path      # 已验证输出dddd
```
[[ ... ]] 是 Bash 中用于条件判断的语法，支持正则表达式匹配。
=~ 运算符用于检查字符串是否匹配给定的正则表达式。
