# shell教程
Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。
在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。
#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。

## 1、两种运行方式
chmod +x test.sh
./test.sh
直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的

/bin/bash test.sh
这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。

## 2、变量
- 注意，变量名和等号之间不能有空格
- 使用一个定义过的变量，只要在变量名前面加美元符号即可
- 推荐给所有变量加上花括号，这是个好的编程习惯。即：echo ${your_name}
- 注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符（$）
- 只读变量：变量定义后换行readonly your_name
- 使用 unset 命令可以删除变量， 不能删除只读变量

## 3、bash上一步参数
!^
!$
!:1

强大如斯的：ctrl + r

## 4、字符串的单双引号
单引号字符串的限制：
单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

双引号的优点：
双引号里可以有变量
双引号里可以出现转义字符


获取字符串长度
string="abcd"
echo ${#string} #输出 4
提取子字符串
以下实例从字符串第 2 个字符开始截取 4 个字符：

string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
注意：第一个字符的索引值为 0。

查找子字符串
查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：

string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
注意： 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。

## 5、数组
bash支持一维数组（不支持多维数组），并且没有限定数组的大小。

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。

使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}


获取数组的长度
获取数组长度的方法与获取字符串长度的方法相同，例如：
```
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```

## 6、多行注释
```
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
EOF 也可以使用其他符号，如'!:

:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

## 7、Linux 的字符串截取很有用
```
#!/bin/bash
# 字符串截取（界定字符本身也会被删除）
str="www.runoob.com/linux/linux-shell-variable.html"
echo "str    : ${str}"
echo "str#*/    : ${str#*/}"   # 从 字符串开头 删除到 左数第一个'/'
echo "str##*/    : ${str##*/}"  # 从 字符串开头 删除到 左数最后一个'/'
echo "str%/*    : ${str%/*}"   # 从 字符串末尾 删除到 右数第一个'/'
echo "str%%/*    : ${str%%/*}"  # 从 字符串末尾 删除到 右数最后一个'/'
echo
echo "str#/*    : ${str#/*}"   # 无效果
echo "str##/*    : ${str##/*}"  # 无效果
echo "str%*/    : ${str%*/}"   # 无效果
echo "str%%*/    : ${str%%*/}"  # 无效果
```

有八种方法。
假设有变量 var=http://www.aaa.com/123.htm

1. # 号截取，删除左边字符，保留右边字符。

echo ${var#*//}
其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符

即删除 http://

结果是 ：www.aaa.com/123.htm

2. ## 号截取，删除左边字符，保留右边字符。

echo ${var##*/}
##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符

即删除 http://www.aaa.com/

结果是 123.htm

3. %号截取，删除右边字符，保留左边字符

echo ${var%/*}
%/* 表示从右边开始，删除第一个 / 号及右边的字符

结果是：http://www.aaa.com

4. %% 号截取，删除右边字符，保留左边字符

echo ${var%%/*}
%%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符

结果是：http:

5. 从左边第几个字符开始，及字符的个数

echo ${var:0:5}
其中的 0 表示左边第一个字符开始，5 表示字符的总个数。

结果是：http:

6. 从左边第几个字符开始，一直到结束。

echo ${var:7}
其中的 7 表示左边第8个字符开始，一直到结束。

结果是 ：www.aaa.com/123.htm

7. 从右边第几个字符开始，及字符的个数

echo ${var:0-7:3}
其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。

结果是：123

8. 从右边第几个字符开始，一直到结束。

echo ${var:0-7}
表示从右边第七个字符开始，一直到结束。

结果是：123.htm

注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）


## 8、expr命令
计算字符长度也可是使用 length:

string="hello,everyone my name is xiaoming"
expr length "$string"
输出:34

注意：string字符串里边有空格,所以需要添加双引号

使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:

expr 5+6    // 直接输出 5+6
expr 5 + 6       // 输出 11
对于某些运算符，还需要我们使用符号"\"进行转义，否则就会提示语法错误。

expr 5 * 6       // 输出错误
expr 5 \* 6      // 输出30

## 9、read 命令用于获取键盘输入信息
-p 参数由于设置提示信息：

```
read -p "input a val:" a    #获取键盘输入的 a 变量数字
read -p "input b val:" b    #获取键盘输入的 b 变量数字
r=$[a+b]                    #计算a+b的结果 赋值给r  不能有空格
echo "result = ${r}"        #输出显示结果 r
```

## 10、脚本参数
$1：脚本名称
$2：第一个参数
$n：第n个参数

参数处理|说明
:--:|:--:
$#	|传递到脚本的参数个数
$*	|以一个单字符串显示所有向脚本传递的参数。
如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$$	|脚本运行的当前进程ID号
$!	|后台运行的最后一个进程的ID号
$@	|与$*相同，但是使用时加引号，并在引号中返回每个参数。
如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-	|显示Shell使用的当前选项，与set命令功能相同。
$?	|显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

### $* 与 $@ 区别
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。



## 11、Shell 中的中括号用法总结

### 算术比较

对变量或值进行算术条件判断：

```
[ $var -eq 0 ]  # 当 $var 等于 0 时，返回真
[ $var -ne 0 ]  # 当 $var 不等于 0 时，返回真
```

需要注意的是 [ 与 ] 与操作数之间一定要有一个空格，否则会报错。比如下面这样就会报错:

```
[$var -eq 0 ]  或 [ $var -ne 0] 
```

其他比较操作符：

| 操作符 | 意义       |
| :----- | :--------- |
| -gt    | 大于       |
| -lt    | 小于       |
| -ge    | 大于或等于 |
| -le    | 小于或等于 |

可以通过 -a (and) 或 -o (or) 结合多个条件进行测试：

```
[ $var1 -ne 0 -a $var2 -gt 2 ]  # 使用逻辑与 -a
[ $var1 -ne 0 -o $var2 -gt 2 ]  # 使用逻辑或 -o
```

### 文件系统属性测试

使用不同的条件标志测试不同的文件系统属性。

| 操作符             | 意义                                                         |
| :----------------- | :----------------------------------------------------------- |
| `[ -f $file_var ]` | 变量 $file_var 是一个正常的文件路径或文件名 (file)，则返回真 |
| `[ -x $var ]`      | 变量 $var 包含的文件可执行 (execute)，则返回真               |
| `[ -d $var ]`      | 变量 $var 包含的文件是目录 (directory)，则返回真             |
| `[ -e $var ]`      | 变量 $var 包含的文件存在 (exist)，则返回真                   |
| `[ -c $var ]`      | 变量 $var 包含的文件是一个字符设备文件的路径 (character)，则返回真 |
| `[ -b $var ]`      | 变量 $var 包含的文件是一个块设备文件的路径 (block)，则返回真 |
| `[ -w $var ]`      | 变量 $var 包含的文件可写(write)，则返回真                    |
| `[ -r $var ]`      | 变量 $var 包含的文件可读 (read)，则返回真                    |
| `[ -L $var ]`      | 变量 $var 包含是一个符号链接 (link)，则返回真                |

### 字符串比较

在进行字符串比较时，最好使用双中括号 [[ ]]. 因为单中括号可能会导致一些错误，因此最好避开它们。

检查两个字符串是否相同：

```
[[ $str1 = $str2 ]]
```

当 str1等于str1等于str2 时，返回真。也就是说，str1 和 str2 包含的文本是一样的。其中的单等于号也可以写成双等于号，也就是说，上面的字符串比较等效于 [[ $str1 == $str2 ]]。

注意 = 前后有一个空格，如果忘记加空格, 就变成了赋值语句，而非比较关系了。

字符串的其他比较情况：

| 操作符                 | 意义                               |
| :--------------------- | :--------------------------------- |
| `[[ $str1 != $str2 ]]` | 如果 str1 与 str2 不相同，则返回真 |
| `[[ -z $str1 ]]`       | 如果 str1 是空字符串，则返回真     |
| `[[ -n $str1 ]]`       | 如果 str1 是非空字符串，则返回真   |

使用逻辑运算符 && 和 || 可以轻松地将多个条件组合起来, 比如：

```
str1="Not empty"
str2=""
if [[ -n $str1 ]] && [[ -z $str2 ]];
then
  echo str1 is nonempty and str2 is empty string.
fi
```

test 命令也可以从来执行条件检测，用 test 可以避免使用过多的括号，[] 中的测试条件同样可以通过 test 来完成。

```
if [ $var -eq 0 ]; then echo "True"; fi
```

等价于:

```
if test $var -eq 0; then echo "True"; fi
```



## 12、数组

数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。

与大部分编程语言类似，数组元素的下标由0开始。

Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：

```
array_name=(value1 value2 ... valuen)
```

使用@ 或 * 可以获取数组中的所有元素。

获取数组长度的方法与获取字符串长度的方法相同。

```
my_array=(A B "C" D)

echo "第一个元素为: ${my_array[0]}"
echo "数组的元素为: ${my_array[*]}"
echo "数组的元素为: ${my_array[@]}"
echo "数组元素个数为: ${#my_array[*]}"
echo "数组元素个数为: ${#my_array[@]}"

i=2
echo "i可以直接下标: ${arr[i]}"
echo "i也可以取其值: ${arr[$i]}"
```

### 遍历数组
```
#!/bin/bash

my_arry=(a b "c","d" abc)
echo "-------FOR循环遍历输出数组--------"
for i in ${my_arry[@]};
do
  echo $i
done

echo "-------::::WHILE循环输出 使用 let i++ 自增:::::---------"
j=0
while [ $j -lt ${#my_arry[@]} ]
do
  echo ${my_arry[$j]}
  let j++
  let "j++"
  let j+=1
  j=$[$j+1]
done
```

### 字符串转数组：
```
#!/bin/bash

words="aaa bbb ccc"

#字符串转数组，空格是分隔符
array=(${words// / })
#打印数组最后一个成员
echo ${array[${#array[*]}-1]}
#打印数组长度
echo ${#array[*]}

#字符串不转换为数组，在循环实现以空格为分隔符打印每个成员
for word in ${words}; do
    echo ${word}
done
```

## 13、/bin/bash和/bin/sh的区别
bash遇到脚本错误继续执行后面
sh遇到脚本错误不再执行后面代码
因此推荐使用bash

1. sh一般设成bash的软链
[work@zjm-testing-app46 cy]$ ll /bin/sh
lrwxrwxrwx 1 root root 4 Nov 13 2006 /bin/sh -> bash
2. 在一般的linux系统当中（如redhat），使用sh调用执行脚本相当于打开了bash的POSIX标准模式
3. 也就是说 /bin/sh 相当于 /bin/bash --posix

所以，sh跟bash的区别，实际上就是bash有没有开启posix模式的区别

so，可以预想的是，如果第一行写成 #!/bin/bash --posix，那么脚本执行效果跟#!/bin/sh是一样的（遵循posix的特定规范，有可能就包括这样的规范：“当某行代码出错时，不继续往下解释”）

# 14、













