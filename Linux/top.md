# top命令

## 1、查看多核CPU命令
mpstat -P ALL  和  sar -P ALL 
说明：sar -P ALL > aaa.txt   重定向输出内容到文件 aaa.txt

## 2、详解
```
top - 14:35:23 up 16 days,  5:29,  1 user,  load average: 0.11, 0.11, 0.09
Tasks: 168 total,   1 running, 167 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.7 us,  3.2 sy,  0.0 ni, 94.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8175056 total,  4722520 free,   318240 used,  3134296 buff/cache
KiB Swap:  2095100 total,  2095100 free,        0 used.  7410892 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 1318 avahi     20   0   45176   3952   3336 S   0.3  0.0  28:24.32 avahi-daemon
20127 root      20   0   44656   3828   3172 R   0.3  0.0   0:00.04 top
    1 root      20   0  119724   5744   3848 S   0.0  0.1   0:05.36 systemd
```

 第一行：
    10:08:45 — 当前系统时间
    10 days, 3:05 — 系统已经运行了10天3小时5分钟（在这期间没有重启过）
    1 users — 当前有1个用户登录系统
    load average: 0.00, 0.00, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。

load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

    第二行：
    Tasks — 任务（进程），系统现在共有135个进程，其中处于运行中的有1个，134个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

    第三行：cpu状态
    0.3% us — 用户空间占用CPU的百分比。
    0.0% sy — 内核空间占用CPU的百分比。
    0.0% ni — 改变过优先级的进程占用CPU的百分比
    99.7% id — 空闲CPU百分比
    0.0% wa — IO等待占用CPU的百分比
    0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
    0.0% si — 软中断（Software Interrupts）占用CPU的百分比

在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。

    第四行：内存状态
    3808060k total — 物理内存总量（4GB）
    3660048k used — 使用中的内存总量（3.6GB）
    148012k free — 空闲内存总量（148M）
    359760k buffers — 缓存的内存量 （359M）

    第五行：swap交换分区
    4184924k total — 交换区总量（4G）
    0k used — 使用的交换区总量（0M）
    4184924k free — 空闲交换区总量（4G）
    2483956k cached — 缓冲的交换区总量（2483M）

第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。

如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：148M+259M+2483M = 2990M。

对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。

 第六行是空行

    第七行以下：各进程（任务）的状态监控
    PID — 进程id
    USER — 进程所有者
    PR — 进程优先级
    NI — nice值。负值表示高优先级，正值表示低优先级
    VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
    RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
    SHR — 共享内存大小，单位kb
    S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
    %CPU — 上次更新到现在的CPU时间占用百分比
    %MEM — 进程使用的物理内存百分比
    TIME+ — 进程使用的CPU时间总计，单位1/100秒
    COMMAND — 进程名称（命令名/命令行）



在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况
如果不按1，则在top视图里面显示的是所有cpu的平均值。

## 3、free命令详解
命令行直接free：（默认单位kb）

列1：total：物理内存的总大小
列2：used：被使用的大小
列3：free：可用内存空闲内存大小
列4：shared：被多个进程共享的内存
列5：buffer/cached:磁盘缓存的大小
列6：available：还可以被进程使用的物理内存大小

同步数据到磁盘
sync

根据需求清除对于缓存
echo 3 > /proc/sys/vm/drop_caches

参数说明：
0 //默认是0；
1-清空页缓存；
2-清空inode和目录树缓存；
3-清空所有缓存

## 4、linux跑程序占用缓存过多释放内存echo 3 ＞ /proc/sys/vm/drop_caches
在跑pytorch时出现了占用内存过多的问题，当然这个问题可以通过调小num_workers解决，不过还有手动解决办法就是释放内存，命令如下：

echo 3 > /proc/sys/vm/drop_caches

而这样会显示权限不足，如果前面加上sudo命令也不行，因为这时候sudo 只是让 echo 命令具有了 root 权限，但是并没有让 “>” 命令也具有root 权限，所以 bash 会认为这个命令没有写入信息的权限。

解决办法：

sudo bash -c "echo 3 > /proc/sys/vm/drop_caches" 

还是不行。

该处出现的问题具有特殊性，只有在docker环境下才可能出现。
问题其实很简单，程序中有相应的代码在程序执行前想通过修改文件的方式释放缓存，但是在docker容器中，无法在容器内部对此文件/proc/sys/vm/drop_caches进行操作，因此出现了频繁要求sudo权限输入密码的情况（实际上并没有啥用），虽然其实并不会影响我们程序的执行，但这大大的阻碍了程序的自动化，解决这个问题其实只需要注释掉释放内存的代码即可，由人工在容器外部手动释放。

## 5、流量查询iftop命令
iftop界面说明 ：
第一行：带宽显示
中间部分：外部连接列表，即记录了哪些ip正在和本机的网络连接
中间部分右边：实时参数分别是该访问ip连接到本机2秒，10秒和40秒的平均流量

=>代表发送数据，<= 代表接收数据

底部三行：表示发送，接收和全部的流量
底部三行第二列：为你运行iftop到目前流量
底部三行第三列：为高峰值
底部三行第四列：为平均值

界面上面显示的是类似刻度尺的刻度范围，为显示流量图形的长条作标尺用的。
中间的<= =>这两个左右箭头，表示的是流量的方向。
TX：发送流量
RX：接收流量
TOTAL：总流量
Cumm：运行iftop到目前时间的总流量
peak：流量峰值
rates：分别表示过去 2s 10s 40s 的平均流量

有个盲区，比如使用iftop时，单位为bytes时。
则1000 000bytes大概是多少？
答案为1MB，即平时常见的8Mb。
大B为byte，小b为bit。而不是看单词中的大小写。

