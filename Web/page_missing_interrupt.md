# 缺页中断

## 1、内存页
操作系统以内存页为单位管理内存，内存页的大小对系统性能有影响。内存页设得太小，内存页会很多，管理内存页的数组会比较大，耗内存，同时TLB大小是固定的，导致TLB MISS增加。所谓TLB就是把虚拟内存页面与物理内存页面的转换结果存起来，不用每次都用MMU作转换。内存页设大了，因为一个进程拥有的内存是内存页大小的整数倍，会导致碎片，即申请了很多内存，真正用到的只有一点。如果考虑SWAP分区（即把硬盘当内存用，在WINDOWS下应该叫虚拟内存），需要把硬盘数据读入内存，硬盘的读性是，连续读大片数据比分多次读小数据要快，这时候应该把内存页大小设大些
在不同的应用场合，内存页的大小的最优值是不同的。所以一般的系统都支持多种内存页的取值。
就线上服务器来说，一般是只跑少数几个进程，内存大都是被某个进程所用，这时候可以把内存页设得比较大

### 1-1、内存分页
分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。

要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。

实现分页的基本方法涉及将物理内存分为固定大小的块，称为帧或页帧，而将逻辑内存也分为同样大小的块，称为页或页面。在 Linux 下，每一页的大小为 4KB。

虚拟地址与物理地址之间通过页表来映射。

### 1-2、页 （Flash芯片单位）
Flash芯片管理数据的最小单位是页，这里的页就相当于硬盘里边簇（Cluster）的概念，即包含页头、多个节区和页尾。
即：页结构=页头+节区xN+页尾，当然页结构不是固定不变的，对于不同的厂家会有所不同，在FLASH数据恢复大师里面已经集成了常见的页结构信息，用户只需要根据页大小来选择不同的结构，如页长度为2112的就存在以下几种情况：
2112=0+（512+16）x4+0
2112=30+（512+8）x4+2
2112=0+512x4+16x4
通常flash页每页含有512个字节，对于任何flash页的写入操作只能在空或已擦除的单元内进行,所以大多数情况下,在进行写入操作之前必须先执行擦除。而对于页的擦除，需要注意的是，擦除必须擦除完整一页，所以页是最小单位。

### 1-3、Flash （存储芯片之一）
flash是存储芯片的一种，通过特定的程序可以修改里面的数据。FLASH在电子以及半导体领域内往往表示Flash Memory的意思，即平时所说的“闪存”，全名叫Flash EEPROM Memory。
flash存储器又称闪存，它结合了ROM和RAM的长处，不仅具备电子可擦除可编程（EEPROM）的性能，还可以快速读取数据（NVRAM的优势），使数据不会因为断电而丢失。

## 2、大页内存(HugePages)
程序性能优化方法—大页内存（HugePages），简单来说就是通过增大操作系统页的大小来减少页表，从而避免快表缺失。
大页内存可以算是一种非常通用的优化技术，应用范围很广，针对不同的应用程序，最多可能会带来50%的性能提升，优化效果还是非常明显的。
大页内存也有适用范围，程序耗费内存很小或者程序的访存局部性很好，大页内存很难获得性能提升。所以，如果你面临的程序优化问题有上述两个特点，请不要考虑大页内存。


## 3、缺页中断
缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。

页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。
通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。
虽然其名为“页缺失”错误，但实际上这并不一定是一种错误。而且这一机制对于利用虚拟内存来增加程序可用内存空间的操作系统（比如Microsoft Windows和各种类Unix系统）中都是常见且有必要的。
微软在较新版Windows的资源监视器中使用“硬错误”（Windows Vista及以上）、“硬中断”（Windows 8及以上）这一术语来指代“页缺失”。

https://blog.csdn.net/weixin_43482279/article/details/105978774
缺页中断LRU算法模拟实现——vector（c++）
缺页中断FIFO算法模拟实现——vector（c++）
缺页中断OPT算法模拟实现——vector（c++）

### 3-1、什么是缺页中断？
进程线性地址空间里的页面不必常驻内存，在执行一条指令时，如果发现它要访问的页没有在内存中（即存在位为0），那么停止该指令的执行，并产生一个页不存在的异常，对应的故障处理程序可通过从外存加载该页的方法来排除故障，之后，原先引起的异常的指令就可以继续执行，而不再产生异常。

### 3-2、页面调度算法
将新页面调入内存时，如果内存中所有的物理页都已经分配出去，就按照某种策略来废弃整个页面，将其所占据的物理页释放出来。


### 3-3、查看进程发生缺页中断的次数
```
[root@ubuntu0006:/media/hankin/vdb/study/read_write] #ps -o majflt,minflt -C sshd
MAJFLT MINFLT
     0   1070
     0    720
     0    654
majflt和minflt表示一个进程自启动以来所发生的缺页中断的次数。
```

### 3-4、产生缺页中断的几种情况
1、当内存管理单元（MMU）中确实没有创建虚拟物理页映射关系，并且在该虚拟地址之后再没有当前进程的线性区（vma）的时候，可以肯定这是一个编码错误，这将杀掉该进程；

2、当MMU中确实没有创建虚拟页物理页映射关系，并且在该虚拟地址之后存在当前进程的线性区vma的时候，这很可能是缺页中断，并且可能是栈溢出导致的缺页中断；

3、当使用malloc/mmap等希望访问物理空间的库函数/系统调用后，由于linux并未真正给新创建的vma映射物理页，此时若先进行写操作，将和2产生缺页中断的情况一样；若先进行读操作虽然也会产生缺页异常，将被映射给默认的零页，等再进行写操作时，仍会产生缺页中断，这次必须分配1物理页了，进入写时复制的流程；

4、当使用fork等系统调用创建子进程时，子进程不论有无自己的vma，它的vma都有对于物理页的映射，但它们共同映射的这些物理页属性为只读，即linux并未给子进程真正分配物理页，当父子进程任何一方要写相应物理页时，导致缺页中断的写时复制；

## 4、逻辑地址 vs 物理地址
https://blog.csdn.net/qq_46344220/article/details/124811775
宿舍四个人一起出去旅行，四个人的学号尾号分别是0、1、2、3。
住酒店时酒店给你们安排了4个房号相连的房间。四个人按学号递增次序入住房间。比如0、1、2、3号同学分别入住了5、6、7、8号房间。
四个人的编号0、1、2、3其实是一个“相对位置”，而各自入住的房间号是一个“绝对位置”。只要知道О号同学住的是房号为N的房间，那么M号同学的房号一定是N+M。
也就是说，只要知道各个同学的“相对位置”和“起始房号”，就一定可以算出所有同学的“绝对位置”

指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”

相对地址又称逻辑地址,绝对地址又称物理地址。





