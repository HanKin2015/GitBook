# 条件变量和互斥量

条件变量与互斥量通常一起使用，原因是线程在因条件未满足而阻塞并等待前，需要访问“条件”，而“条件”是允许其它线程修改的，因此，访问“条件”时需要加锁，访问结束后释放锁。所以，这也就可以解释，条件变量的等待操作pthread_cond_wait()需要一个互斥量参数，在pthread_cond_wait()内部将调用线程放到等待队列上后，要解锁互斥量，以让其它线程可以访问“条件”；否则，该线程将一直占用互斥量，其它线程将不能访问“条件”。不过，pthread_cond_wait()内的解锁互斥量只是临时的，在其它线程修改“条件”使其满足要求并唤醒当前阻塞线程时，pthread_cond_wait()内部又会锁住互斥量，这样做的目的是：

使互斥量的状态在进入、退出pthread_cond_wait()函数时保持一致；
本身“判断‘条件’是否满足要求，否则阻塞并等待‘条件’”这部分程序属于临界区，在访问临界区前对互斥量加锁，退出临界区后对互斥量解锁是应有的操作，也就是说，真正地释放互斥量锁的操作在退出临界区后；所以，在pthread_cond_wait()函数结束时，应保持互斥量的加锁状态；

## 总结
条件变量算是一个临界资源，每个线程都能进行访问修改，因此需要加锁虎次郎访问。



