# 把引用作为返回值

## 1、简介
通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。
当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。
当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。
（1）以引用返回函数值，定义函数时需要在函数名前加 &
（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

引用作为返回值，必须遵守以下规则：
（1）不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
（2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
（3）可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

是不是有点像函数式编程。

## 2、示例
```
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
}
 
// 要调用上面定义函数的主函数
int main ()
{
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}

int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```

## 3、使用引用类型时必须在定义时进行初始化
```
std::vector<BYTE>  & desc = config_descriptor_list[config_index]; 
```
在这个语句中，& 符号是一个引用符号，它表示将 config_descriptor_list[config_index] 的值作为一个引用传递给 desc 变量。这意味着 desc 变量将引用 config_descriptor_list[config_index] 的内存地址，而不是创建一个新的副本。这样做的好处是可以避免在复制大型数据结构时产生额外的开销，同时也可以确保对 desc 变量所做的更改会反映在 config_descriptor_list[config_index] 中。

如果想修改成先定义再引用赋值是不可以的，即：
```
都是错误的演示：
std::vector<BYTE> & desc;
desc = config_descriptor_list[config_index];

std::vector<BYTE> desc;
& desc = config_descriptor_list[config_index];
```

在C++中，使用引用类型时必须在定义时进行初始化，否则会导致编译错误。这是因为引用类型本质上是一个别名，它必须引用一个已经存在的对象，而不是创建一个新的对象。因此，引用类型必须在定义时初始化为一个已经存在的对象。

例如，以下代码定义了一个整数引用类型变量，并将其初始化为一个整数变量x：
```
int x = 10;
int& ref = x; // 引用类型变量ref必须在定义时初始化为x
```

如果不进行初始化，编译器会报错，例如：
```
int& ref; // 编译错误：引用类型变量必须进行初始化
```
因此，在使用引用类型时，必须始终记住进行初始化。