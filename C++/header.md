# 头文件

## 0、结论
建议使用#ifndef，移植性更好
```
#ifndef STUDY_HEADER_H
#define STUDY_HEADER_H

#endif /* STUDY_HEADER_H */
```

## 1、#pragma once和#ifndef
为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。
在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。
```
方式一：

#ifndef  __SOMEFILE_H__
#define  __SOMEFILE_H__
... ... // 声明、定义语句
#endif

方式二：

#pragmaonce
... ... // 声明、定义语句
```

`#pragma once`是一个比较常用的C/C++预处理指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次。

（1）#ifndef
#ifndef的方式受C/C++语言标准支持。它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。
当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。
由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once的方式。

（2）#pragma once
#pragma once 一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。
你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。
其好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些。
对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。
另外，这种方式不支持跨平台！

https://www.cnblogs.com/qiang-upc/p/11407364.html
https://en.jinzhao.wiki/wiki/Pragma_once

#pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差，不过现在基本上已经是每个编译器都有这个定义了。

## 2、头文件不规范导致重复定义问题
头文件里只能有函数声明，不能有函数定义，除非增加static修饰
头文件里不能有变量声明或定义，除非增加static修饰，或者extern修饰声明








